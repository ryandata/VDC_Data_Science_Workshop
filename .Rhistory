ggtheme = theme_bw()
)
fviz_cluster(my_k_scaled, rescaled_parking[, ..features],
palette = c("blue", "red", "green","black"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
my_k$tot.withinss
kmean_withinss <- function(k) {
cluster <- kmeans(rescaled_parking, k)
return (cluster$tot.withinss)
}
# Set maximum cluster
max_k <-20
# Run algorithm over a range of k
wss <- sapply(2:max_k, kmean_withinss)
# Create a data frame to plot the graph
elbow <-data.frame(2:max_k, wss)
ggplot(elbow, aes(x = X2.max_k, y = wss)) +
geom_point() +
geom_line() +
scale_x_continuous(breaks = seq(1, 20, by = 1))
summary(parkingsample)
library(mltools)
names(parkingsample)
table(is.na(parksample_nochar$`Violation Location`))
table(is.na(parksample$`Violation Location`))
table(is.na(parkingsample$`Violation Location`))
names(parkingsample)
# let's restrict to a subset for this section
parkingsample <- parkingsample[,-c(1:2,10:13,16:20,22:31,36:44)]
names(parkingsample)
summary(parkingsample)
names(parkingsample)
# let's restrict to a subset for this section
parkingsample <- parkingsample[,-13]
summary(parkingsample)
names(parkingsample)
# let's restrict to a subset for this section
parkingsample <- parkingsample[,-3]
names(parkingsample)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample)
View(parkingsample_1)
?one_hot
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, c(1,2,4,5))
View(parkingsample_1)
View(parkingsample_1)
names(parkingsample_1)
names(parkingsample)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, c(2,4))
names(parkingsample_1)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, c(2,5))
names(parkingsample_1)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, c(5))
names(parkingsample_1)
names(parkingsample)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, c(9))
names(parkingsample)
names(parkingsample_1)
rm(parkingsample_1)
names(parkingsample)
table(parkingsample$`Vehicle Color`)
table(parkingsample$`Violation County`)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, c(9))
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, 9)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, col=`Violation County`)
# we can one-hot encode using function from mltools
parkingsample_1 <- one_hot(parkingsample, col="Violation County")
names(parkingsample_1)
library(caret)
library(caret)
inTrain <- createDataPartition(y = iris$Species, p = .7, list = FALSE)
iris.train <- iris[inTrain, ]
iris.test <- iris[- inTrain, ]
fit.control <- caret::trainControl(method = "cv", number = 10)
rf.fit <- caret::train(Species ~ .,
data = iris.train,
method = "rf",
trControl = fit.control)
?createDataPartition
createFolds(parksample_nochar, k=5)
inTrain <- createDataPartition(parksample_nochar, p = .8, list = FALSE)
names(iris)
inTrain <- createDataPartition(y = iris$Species, p = .8, list = FALSE)
inTrain
head(iris)
data_ctrl <- trainControl(method = "cv", number = 5)
?train
names(parksample_nochar)
summary(parksample_nochar)
# using caret
TrainData <- parksample_nochar[,1:5]
knnFit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
tuneLength = 10,
trControl = trainControl(method = "cv"))
# using caret
TrainData <- parksample_nochar[,1:5]
TrainClasses <- parksample_nochar[,6]
# using caret
TrainData <- parksample_nochar[,1:5]
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
trControl = trainControl(method = "cv"))
?train
# using caret
TrainData <- as.data.frame(parksample_nochar[,1:5])
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
trControl = trainControl(method = "cv"))
TrainClasses <- as.data.frame(parksample_nochar[,6])
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
trControl = trainControl(method = "cv"))
names(parksample_nochar)
summary(parksample_nochar)
str(parksample_nochar)
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
trControl = trainControl(method = "cv"))
TrainClasses <- as.numeric(parksample_nochar[,6])
# using caret
TrainData <- parksample_nochar[,1:5]
TrainClasses <- as.numeric(parksample_nochar[,6])
TrainClasses <- parksample_nochar[,6]
TrainClasses
mode(TrainClasses)
class(TrainClasses)
TrainClasses
names(parksample_nochar)
View(rescaled_parking)
str(rescaled_parking)
# using caret
TrainData <- rescaled_parking[,1:5]
TrainClasses <- rescaled_parking[,6]
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
trControl = trainControl(method = "cv"))
?train
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"))
rescaled_parking$`Feet From Curb`
str(rescaled_parking$`Feet From Curb`)
head(iris)
names(rescaled_parking)
# using caret
TrainData <- rescaled_parking[,1:4]
# using caret
TrainData <- rescaled_parking[,1:4]
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"))
# using caret
TrainData <- as.matrix(rescaled_parking[,1:5])
# using caret
TrainData <- as.matrix(rescaled_parking[,1:5])
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"))
TrainClasses <- as.matrix(rescaled_parking$`Feet From Curb`)
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"))
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "boot"))
?train
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
metric = "Accuracy")
# using caret
TrainData <- as.matrix(rescaled_parking[,1:5])
s
TrainClasses <- as.matrix(rescaled_parking[,6])
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
metric = "Accuracy")
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
metric = "Kappa")
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
tuneLength = 10,
metric = "Kappa")
# using caret
TrainData <- rescaled_parking[,1:5]
TrainClasses <- rescaled_parking[,6]
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
tuneLength = 10,
metric = "Kappa")
# using caret
TrainzData <- as.matrix(rescaled_parking[,1:5])
# using caret
TrainData <- as.matrix(rescaled_parking[,1:5])
TrainClasses <- as.matrix(rescaled_parking[,6])
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
tuneLength = 10,
metric = "Kappa")
?trainControl
names(rescaled_parking)
# using caret
TrainData <- as.matrix(rescaled_parking[,5])
TrainClasses <- as.matrix(rescaled_parking[,6])
knnit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
tuneLength = 10,
metric = "Kappa")
?train
knnFit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
tuneLength = 1000,
metric = "Kappa")
knnFit1 <- train(TrainData, TrainClasses,
method = "knn",
trControl = trainControl(method = "cv"),
tuneLength = 1000000,
metric = "Kappa")
# using caret
trainRowNumbers <- createDataPartition(rescaled_parking$`Feet From Curb`, p=0.8, list=FALSE)
# Create the training  dataset
trainData <- rescaled_parking[trainRowNumbers,]
# Create the test dataset
testData <- rescaled_parking[-trainRowNumbers,]
featurePlot(x,y,
plot = "box",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
# Store X and Y for later use.
x = trainData[, 1:5]
y = trainData$`Feet From Curb`
featurePlot(x,y,
plot = "box",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
t
y
class(y)
?featurePlot
e
featurePlot(x,y,
plot = "scatter",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
featurePlot(x,y,
plot = "scatter")
featurePlot(x,y)
getModelInfo()
# See available algorithms in caret
modelnames <- paste(names(getModelInfo()), collapse=',  ')
modelnames
modelLookup('knn')
model_mars = train(Purchase ~ ., data=trainData, method='earth')
model_mars = train(y ~ ., data=trainData, method='earth')
model_mars = train(y ~ ., data=trainData, method='knn')
warnings()
names(rescaled_parking
)
# Store X and Y for later use.
x = trainData[, 5]
y = trainData$`Feet From Curb`
my_model <- train(y ~ ., data=trainData, method='knn')
# define a split of your data for training
trainRowNumbers <- createDataPartition(rescaled_parking$`Feet From Curb`, p=0.01, list=FALSE)
# Create the training  dataset
trainData <- rescaled_parking[trainRowNumbers,]
# Create the test dataset
testData <- rescaled_parking[-trainRowNumbers,]
# Store X and Y for later use.
x = trainData[, 5]
y = trainData$`Feet From Curb`
# See available algorithms in caret
modelnames <- paste(names(getModelInfo()), collapse=',  ')
modelnames
modelLookup('knn')
my_model <- train(y ~ ., data=trainData, method='knn')
?train
my_model <- train(z,y, method='knn')
my_model <- train(x,y, method='knn')
fitted <- predict(my_model)
# define a split of your data for training
trainRowNumbers <- createDataPartition(rescaled_parking$`Feet From Curb`, p=0.8, list=FALSE)
# Create the training  dataset
trainData <- rescaled_parking[trainRowNumbers,]
# Create the test dataset
testData <- rescaled_parking[-trainRowNumbers,]
# Store X and Y for later use.
x = trainData[, 5]
y = trainData$`Feet From Curb`
my_model <- train(x,y, method='knn')
# define a split of your data for training
trainRowNumbers <- createDataPartition(rescaled_parking$`Feet From Curb`, p=0.1, list=FALSE)
# Create the training  dataset
trainData <- rescaled_parking[trainRowNumbers,]
# Create the test dataset
testData <- rescaled_parking[-trainRowNumbers,]
# Store X and Y for later use.
x = trainData[, 5]
y = trainData$`Feet From Curb`
my_model <- train(x,y, method='knn')
warnings()
modelnames
my_model
fitted <- predict(my_model)
my_model
plot(my_model)
fitted
plot(fitted)
predicted <- predict(my_model, testData)
head(predicted)
confusionMatrix(reference = testData$`Feet From Curb`, data = predicted, mode='everything', positive='MM')
names(testData)
confusionMatrix(reference = testData$`Feet From Curb`, data = predicted, mode='everything', positive='MM')
?confusionMatrix
names(predicted)
head(predicted)
head(testData)
confusionMatrix(reference = testData$`Feet From Curb`, data = predicted, mode='everything')
?rmse
rmse(predicted-testData$`Feet From Curb`)
rmse(predicted-testData$`Feet From Curb`, na.rm=TRUE)
preds <- c(1.0, 2.0, 9.5)
actuals <- c(0.9, 2.1, 10.0)
rmse(preds, actuals)
100000*rmse(predicted-testData$`Feet From Curb`, na.rm=TRUE)
len(predicted)
class(predicted)
mode(predicted)
nrow(predicted)
length(predicted)
length(rescaled_parking$`Feet From Curb`)
length(x)
length(y)
length(trainData)
nrow(trainData)
nrow(x)
length(testData)
nrow(testData)
# Create the test dataset
testData <- rescaled_parking[-trainRowNumbers,]
nrow(testData)
rmse(predicted-testData$`Feet From Curb`, na.rm=TRUE)
length(testData$`Feet From Curb`)
length(predicted)
a<-c(1,2,3)
b<-c(2929,23,2)
rmse(a,b)
length(a)
length(b)
class(testData$`Feet From Curb`)
mode(testData$`Feet From Curb`)
rmse(predicted-testData$`Feet From Curb`)
?rmse
predicted-testData$`Feet From Curb`
my_vec<-predicted-testData$`Feet From Curb`
my_vec
my_vec*my_vec
my_vec**my_vec
my_vec^2
mine<-my_vec*my_vec
mine/length(predicted)
sum(mine)/length(predicted)
sqrt(sum(mine/length(predicted)))
# we can also plot across combined dimensions,
# although the interpretation in this case is less clear
my_k <- kmeans(parksample_nochar, centers, nstart=5)
my_k_scaled <- kmeans(rescaled_parking, centers, nstart=5)
fviz_cluster(my_k, parksample_nochar,
palette = c("blue", "red", "green","black"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
fviz_cluster(my_k_scaled, rescaled_parking[, ..features],
palette = c("blue", "red", "green","black"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
kmean_withinss <- function(k) {
cluster <- kmeans(rescaled_parking, k)
return (cluster$tot.withinss)
}
# Set maximum cluster
max_k <-20
# Run algorithm over a range of k
wss <- sapply(2:max_k, kmean_withinss)
# Create a data frame to plot the graph
elbow <-data.frame(2:max_k, wss)
ggplot(elbow, aes(x = X2.max_k, y = wss)) +
geom_point() +
geom_line() +
scale_x_continuous(breaks = seq(1, 20, by = 1))
inTrain <- createDataPartition(y = iris$Species, p = .8, list = FALSE)
createFolds(parksample_nochar, k=5)
iris.train <- iris[inTrain, ]
iris.test <- iris[- inTrain, ]
fit.control <- caret::trainControl(method = "cv", number = 10)
rf.fit <- caret::train(Species ~ .,
data = iris.train,
method = "rf",
trControl = fit.control)
data_ctrl <- trainControl(method = "cv", number = 5)
rf.fit
data_ctrl <- trainControl(method = "cv", number = 5)
model_caret <- train(ACT ~ gender + age + SATV + SATQ,   # model to fit
data = data,
trControl = data_ctrl,              # folds
method = "lm")
# define a split of your data for training
trainRowNumbers <- createDataPartition(rescaled_parking$`Feet From Curb`, p=0.01, list=FALSE)
# Create the training  dataset
trainData <- rescaled_parking[trainRowNumbers,]
# Create the test dataset
testData <- rescaled_parking[-trainRowNumbers,]
# Store X and Y for later use.
x = trainData[, 5]
y = trainData$`Feet From Curb`
# See available algorithms in caret
modelnames <- paste(names(getModelInfo()), collapse=',  ')
modelnames
modelLookup('knn')
my_model <- train(x,y, method='knn')
fitted <- predict(my_model)
my_model
plot(my_model)
model_caret <- train(`Violation Location`~`Issuer Precinct`,   # model to fit
data = parksample_nochar,
trControl = data_ctrl,              # folds
method = "lm")
model_caret <- train(`Vehicle Year`~`Issuer Precinct`,   # model to fit
data = parksample_nochar,
trControl = data_ctrl,              # folds
method = "lm")
model_caret
names(model_caret)
model_caret$finalModel
fviz_cluster(my_k, parksample_nochar[, ..features],
palette = c("blue", "red", "green","black"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
features <- c('Violation Precinct','Issuer Precinct')
centers <- 4
my_k <- kmeans(parksample_nochar[, ..features], centers, nstart=5)
my_k_scaled <- kmeans(rescaled_parking[, ..features], centers, nstart=5)
fviz_cluster(my_k, parksample_nochar[, ..features],
palette = c("blue", "red", "green","black"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
features <- c('Violation Precinct','Issuer Precinct')
centers <- 4
my_k <- kmeans(parksample_nochar[, ..features], centers, nstart=5)
my_k_scaled <- kmeans(rescaled_parking[, ..features], centers, nstart=5)
fviz_cluster(my_k, parksample_nochar[, ..features],
palette = c("blue", "red", "green","black"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
inTrain <- createDataPartition(y = iris$Species, p = .8, list = FALSE)
createFolds(parksample_nochar, k=5)
iris.train <- iris[inTrain, ]
iris.test <- iris[- inTrain, ]
fit.control <- caret::trainControl(method = "cv", number = 10)
rf.fit <- caret::train(Species ~ .,
data = iris.train,
method = "rf",
trControl = fit.control)
rf.fit
names(rf.fit)
plot(my_model)
my_model
?knit
render("VDC_announce.md", output_format="all")
library(rmarkdown)
render("VDC_announce.md", output_format="all")
getwd()
setwd("/Users/ryanwomack/Dropbox/data/VDC/VDC_Data_Science_Workshop/")
render("VDC_announce.md", output_format="all")
